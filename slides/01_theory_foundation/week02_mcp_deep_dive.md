---
marp: true
theme: default
paginate: true
header: '**멀티에이전트 프로토콜 학습 과정**'
footer: 'Week 2: MCP (Model Context Protocol) 심화'
style: |
  section {
    font-size: 22px;
  }
  h1 {
    color: #e74c3c;
  }
  h2 {
    color: #c0392b;
  }
  .highlight {
    background-color: #fff3cd;
    padding: 15px;
    border-left: 4px solid #ffc107;
  }
---

# Week 2: MCP (Model Context Protocol) 심화

## 🔌 "LLM을 위한 USB-C 포트"

---

## 🎯 학습 목표

- **MCP의 핵심 개념**과 "LLM USB-C" 철학 이해
- **Client-Server 아키텍처**의 구조와 동작 원리 파악
- **5가지 핵심 프리미티브** 기능과 활용 방법 학습
- **실제 업계 채택 현황**과 미래 전망 분석

---

## 🚀 MCP란 무엇인가?

### Anthropic의 혁신적 접근
> **"LLM을 위한 USB-C 포트"**
> 
> 마치 USB-C가 다양한 기기를 연결하듯, MCP는 LLM과 외부 도구/데이터를 표준화된 방식으로 연결

### 핵심 철학
- 🔌 **표준화된 연결**: 복잡한 통합 과정 단순화
- 🎯 **컨텍스트 제공**: LLM에게 풍부한 컨텍스트 제공
- 🛡️ **보안 중심**: 안전한 데이터 접근 메커니즘
- 🌐 **생태계 확장**: 다양한 서비스와의 쉬운 통합

---

## 🏗️ MCP 아키텍처 개요

```
    사용자
      ↓
 [Host Application]
      ↓
   [MCP Client]
      ↓ (JSON-RPC 2.0)
   [MCP Server] ←→ [External Data/Tools]
```

### 각 구성요소의 역할
- **Host**: Claude Desktop, Zed, Replit 등
- **Client**: 프로토콜 구현체, 요청 관리
- **Server**: 도구/데이터 제공자, 실제 서비스 연결

---

## 🔧 전송 방식 (Transport Methods)

### 1. HTTP Transport
- **사용 사례**: 웹 기반 서비스, API 연동
- **장점**: 표준화, 방화벽 친화적
- **단점**: 오버헤드 존재

### 2. Stdio Transport  
- **사용 사례**: 로컬 도구, 명령행 프로그램
- **장점**: 빠른 성능, 간단한 설정
- **단점**: 로컬 환경 제한

### 3. Server-Sent Events (SSE)
- **사용 사례**: 실시간 스트리밍, 이벤트 알림
- **장점**: 실시간 통신
- **단점**: 단방향 통신

---

## 📋 5가지 핵심 프리미티브

### 1. 📄 Resources (리소스)
**정의**: LLM이 접근할 수 있는 정보나 데이터
- 파일, 데이터베이스 레코드, API 응답 등
- **예시**: 프로젝트 문서, 코드 파일, 설정 정보

### 2. 🛠️ Tools (도구)
**정의**: LLM이 실행할 수 있는 기능이나 작업
- 계산, API 호출, 파일 조작 등
- **예시**: 이메일 발송, 데이터 분석, 파일 생성

---

## 📋 5가지 핵심 프리미티브 (계속)

### 3. 💬 Prompts (프롬프트)
**정의**: 재사용 가능한 프롬프트 템플릿
- 표준화된 지시사항, 역할 정의 등
- **예시**: 코드 리뷰 템플릿, 분석 가이드라인

### 4. 📁 Roots (루트)
**정의**: 서버가 접근할 수 있는 디렉토리나 범위
- 파일 시스템 접근 범위 제한
- **예시**: 프로젝트 폴더, 특정 디렉토리

### 5. 🎲 Sampling (샘플링)
**정의**: LLM 체인 호출을 통한 복합 작업
- 다단계 추론, 반복적 개선
- **예시**: 코드 생성 → 테스트 → 개선

---

## 🔒 인증 및 보안

### 기본 인증 방식
- **토큰 기반 인증**: API 키, JWT 등
- **선택적 DID 지원**: 분산 신원 확인

### 보안 원칙
1. **데이터 내부화**: 모든 데이터는 인프라 내부에서만 처리
2. **최소 권한**: 필요한 최소한의 접근 권한만 부여
3. **샌드박싱**: 격리된 환경에서 도구 실행
4. **감사 로그**: 모든 접근과 실행 기록

---

## 📊 상태 관리

### 기본 모델: 무상태 (Stateless)
- 각 요청은 독립적으로 처리
- 서버는 이전 요청을 기억하지 않음
- **장점**: 단순성, 확장성
- **단점**: 컨텍스트 손실

### 선택적 기능: 지속적 도구 컨텍스트
- 특정 도구의 상태 유지 가능
- 연속적인 작업에서 성능 향상
- **예시**: 데이터베이스 연결, 세션 관리

---

## 🏢 주요 업체 채택 현황

### 🎯 주요 채택 기업 (2025년 기준)
- **Anthropic**: Claude Desktop 공식 지원
- **OpenAI**: GPT 모델과의 통합 지원
- **Google DeepMind**: 2025년 공식 채택 발표
- **Microsoft**: C# SDK 공동 개발 파트너십

### 💻 개발 도구 통합
- **Zed**: 코드 에디터 내장 지원
- **Replit**: 온라인 IDE 통합
- **Codeium**: AI 코딩 어시스턴트
- **Sourcegraph**: 코드 검색 및 분석

---

## 🌟 기업 파트너십

### Block 파트너십
- **금융 서비스**: 결제, 거래 내역 분석
- **Cash App**: 개인 금융 관리 도구

### Apollo 파트너십  
- **영업 도구**: CRM 데이터 연동
- **고객 관계 관리**: 자동화된 고객 소통

### Microsoft 협력
- **공식 C# SDK**: .NET 생태계 지원
- **Azure 통합**: 클라우드 서비스 연계
- **Office 365**: 문서 및 이메일 도구 연동

---

## 🛠️ 다국어 SDK 현황

### 공식 지원 언어
1. **Python**: 가장 활발한 커뮤니티
2. **TypeScript**: 웹 개발 친화적
3. **Java**: 엔터프라이즈 환경 지원
4. **C#**: Microsoft 공식 협력

### 커뮤니티 지원 언어
- **Rust**: 고성능 시나리오
- **Go**: 클라우드 네이티브 환경
- **Swift**: iOS 앱 개발

---

## 💡 실제 사용 사례

### 1. 개발 환경 통합
```
Developer → Claude Desktop → MCP Server
                              ↓
                    GitHub + Google Drive + Slack
```

### 2. 데이터 분석 파이프라인
```
Analyst → LLM → MCP Server → PostgreSQL + Excel + Tableau
```

### 3. 고객 서비스 자동화
```
Customer → Chatbot → MCP Server → CRM + Knowledge Base + Email
```

---

## 🎮 MCP 실습 시나리오

### Claude Desktop 체험
1. **GitHub 통합**: 코드 리포지토리 접근
2. **Google Drive 연동**: 문서 읽기/쓰기
3. **Slack 메시징**: 팀 커뮤니케이션
4. **PostgreSQL 조회**: 데이터베이스 분석

### 실습 목표
- Resources로 파일 읽기
- Tools로 API 호출하기  
- Prompts로 템플릿 활용
- Sampling으로 복합 작업 수행

---

## 🔄 MCP vs 다른 프로토콜

| 특징 | MCP | 기존 API |
|:---:|:---:|:---:|
| **목적** | LLM 컨텍스트 제공 | 일반적 데이터 교환 |
| **표준화** | 통일된 인터페이스 | 각자 다른 형식 |
| **보안** | 내장된 보안 모델 | 별도 구현 필요 |
| **LLM 최적화** | ✅ 특화 설계 | ❌ 일반 목적 |

### MCP의 독특한 장점
- **컨텍스트 중심**: LLM이 이해하기 쉬운 형태로 데이터 제공
- **통합 단순화**: 복잡한 API 통합을 표준화된 방식으로 해결
- **생태계 효과**: 한 번 구현하면 모든 MCP 클라이언트에서 사용 가능

---

## 📈 MCP 생태계 성장

### 2024년 11월 출시 이후
- **급속한 채택**: 주요 AI 기업들의 공식 지원
- **커뮤니티 성장**: 활발한 개발자 커뮤니티 형성
- **표준화 논의**: 산업 표준으로의 발전 가능성

### 미래 전망
- **더 많은 통합**: 기존 서비스들의 MCP 지원 확산
- **성능 개선**: 프로토콜 최적화 및 새로운 전송 방식
- **보안 강화**: 고급 인증 및 권한 관리 기능
- **국제 표준화**: W3C, IETF 등 표준화 기구 관심

---

## 🔮 다음 주 예고: A2A Protocol

### Agent to Agent Protocol
- **Google의 혁신**: 50+ 기술 파트너와 공동 개발
- **Agent Card 시스템**: JSON 메타데이터 기반 서비스 발견
- **DID 인증**: 분산 신원 확인 메커니즘
- **Opaque Agent**: 내부 상태 노출 없는 안전한 협업

### 비교 관점
- **MCP**: LLM ↔ 도구 연결
- **A2A**: 에이전트 ↔ 에이전트 협업

---

## 📝 이번 주 정리

### 핵심 개념
1. **MCP = LLM의 USB-C**: 표준화된 연결 인터페이스
2. **5가지 프리미티브**: Resources, Tools, Prompts, Roots, Sampling
3. **Client-Server 구조**: JSON-RPC 2.0 기반 통신
4. **보안 중심 설계**: 데이터 내부화, 최소 권한 원칙

### 실무 적용 포인트
- **LLM 도구 통합**이 필요한 모든 시나리오에 적용 가능
- **기존 API들의 MCP 래핑**으로 통합 비용 절감
- **표준화된 접근**으로 개발 생산성 향상

---

## 🎯 과제 안내

### 주간 과제: MCP 서버 설계
1. **자신의 업무/관심사**에 맞는 MCP 서버 시나리오 설계
2. **5가지 프리미티브** 각각에 대한 구체적 사례 제시
3. **보안 고려사항** 및 **해결 방안** 작성
4. **A4 3페이지** 분량으로 작성

### 제출 기한
**다음 주 수업 시작 전까지**

### 선택 과제
Claude Desktop에 MCP 서버 연결해보기 (보너스 점수)

---

## 💭 토론 주제

### 생각해볼 질문들
- 🤔 MCP가 해결하는 진짜 문제는 무엇일까?
- 🤔 "LLM의 USB-C"라는 비유가 적절한가?
- 🤔 MCP의 보안 모델에서 개선할 점은?
- 🤔 어떤 산업/분야에서 MCP가 가장 유용할까?

### 다음 수업 준비
- A2A 공식 문서 훑어보기
- Google Cloud의 에이전트 생태계 알아보기

**감사합니다! 🙏** 